(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{375:function(t,a,e){"use strict";e.r(a);var s=e(40),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"computed-和-watch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-watch"}},[t._v("#")]),t._v(" computed 和 watch")]),t._v(" "),e("ol",[e("li",[e("h3",{attrs:{id:"什么是computed"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是computed"}},[t._v("#")]),t._v(" 什么是computed")])])]),t._v(" "),e("ul",[e("li",[t._v("computed是不支持异步，异步在computed里无效；")]),t._v(" "),e("li",[t._v("computed场景适合多对一，一对一，如果一个属性是由其他属性计算而来的，这个属性依赖其他属性。")]),t._v(" "),e("li",[t._v("支持缓存只有数据发生变化的适合才会重新计算")]),t._v(" "),e("li",[t._v("里边有set，get方法，当数据发生变化时set也会变")])]),t._v(" "),e("hr"),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[e("h3",{attrs:{id:"什么是watch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是watch"}},[t._v("#")]),t._v(" 什么是watch")])])]),t._v(" "),e("ul",[e("li",[t._v("watch不支持缓存，数据变就跟着变，支持异步")]),t._v(" "),e("li",[t._v("watch一个属性改变多个属性跟着变适合一对多")]),t._v(" "),e("li",[t._v("watch必须data，props中存在")]),t._v(" "),e("li",[t._v("watch接受两个参数一个是新值，一个是旧值")])]),t._v(" "),e("hr"),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[e("h3",{attrs:{id:"两者的运用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#两者的运用场景"}},[t._v("#")]),t._v(" 两者的运用场景")])])]),t._v(" "),e("ul",[e("li",[t._v("当我们需要进行数值计算,并且依赖于其它数据时,应该使用 computed,因为可以利用 computed 的缓存特性,避免每次获取值时,都要重新计算。")]),t._v(" "),e("li",[t._v("当我们需要在数据变化时执行异步或开销较大的操作时,应该使用 watch,使用 watch 选项允许我们执行异步操作 ( 访问一个 API ),限制我们执行该操作的频率,并在我们得到最终结果前,设置中间状态。这些都是计算属性无法做到的")])]),t._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[e("h3",{attrs:{id:"computed里面使用if语句后-vue会监听到if语句"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed里面使用if语句后-vue会监听到if语句"}},[t._v("#")]),t._v(" computed里面使用if语句后，vue会监听到if语句")])])]),t._v(" "),e("ul",[e("li",[t._v("不能")])])])}),[],!1,null,null,null);a.default=r.exports}}]);